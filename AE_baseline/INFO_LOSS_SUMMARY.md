# ⚠️ 정보 손실 요약 - 3D → 2D 변환

## 개요
CQ500 데이터는 원래 **3D CT 볼륨**이지만, 기존 reconstruction 코드가 **2D 전용**이기 때문에 3D 볼륨을 2D 슬라이스로 변환하여 사용합니다.

이 과정에서 **불가피한 정보 손실**이 발생합니다.

---

## 📍 정보 손실 지점

### 1️⃣ **[정보 손실 1] - 슬라이스 변환** (`dataload.py:84-88`)
```python
# 3D 볼륨을 2D 슬라이스로 변환하여 저장
self.slice_data = []  # [(sample_name, slice_idx, label), ...]
self._prepare_slices()
```

**손실 내용:**
- 각 3D 볼륨(D×H×W)을 D개의 2D 슬라이스(H×W)로 분할
- **Slice 간 공간적 연속성 정보 손실**
- 예: (29, 512, 512) 볼륨 → 29개의 (512, 512) 독립 슬라이스

**영향:**
- Depth 방향으로 이어지는 병변의 연속성을 알 수 없음
- 3D context가 제거됨

---

### 2️⃣ **[정보 손실 2] - 슬라이스 분할** (`dataload.py:137-144`)
```python
def _prepare_slices(self):
    """
    ⚠️ [정보 손실 2] 3D 볼륨을 2D 슬라이스로 분할
    
    각 3D 볼륨을 여러 개의 2D 슬라이스로 나누어 저장
    - Depth 방향 정보 손실
    - Slice 간 관계 무시
    """
```

**손실 내용:**
- 각 슬라이스가 독립적인 샘플로 취급됨
- **인접 슬라이스 간 관계 정보 손실**

**영향:**
- Slice N과 Slice N+1의 관계를 모델이 학습할 수 없음
- 3D 공간 정보 완전 무시

---

### 3️⃣ **[정보 손실 3] - 양 끝 슬라이스 제거** (`dataload.py:161-165`)
```python
# 전체 슬라이스 중 중간 80% 사용 (양 끝 10%씩 제외)
# ⚠️ [정보 손실 3] 볼륨의 양 끝 슬라이스는 정보가 적어 제외
depth = volume.shape[0]
start_idx = int(depth * 0.1)
end_idx = int(depth * 0.9)
```

**손실 내용:**
- 볼륨의 상단 10% + 하단 10% 슬라이스 제거
- **전체 데이터의 20% 손실**

**이유:**
- CT 스캔의 양 끝은 노이즈가 많거나 관심 영역이 아님
- 중간 부분(뇌 중심부)에 중요 정보가 집중

**영향:**
- 양 끝에 있는 병변이 있다면 감지 불가
- 데이터 양 20% 감소

---

### 4️⃣ **[정보 손실 4] - 단일 슬라이스만 반환** (`dataload.py:186-226`)
```python
def __getitem__(self, index: int) -> dict:
    """
    2D 슬라이스 반환
    
    ⚠️ [정보 손실 4] 단일 2D 슬라이스만 반환
    - 인접 슬라이스 정보 없음
    - 3D spatial context 손실
    """
    # ...
    slice_2d = volume[slice_idx, :, :]  # (H, W) - 단일 슬라이스!
    return {"img": img, ...}  # (1, H, W) - 2D!
```

**손실 내용:**
- `__getitem__`이 단일 2D 이미지만 반환
- **인접 슬라이스 정보 완전 손실**

**영향:**
- 모델이 2D CNN으로만 학습 가능 (3D CNN 불가)
- Spatial context 부족으로 정확도 하락 가능

---

## 📊 정보 손실 비교

| 항목 | 3D 방식 (이상적) | 2D Slice 방식 (현재) |
|------|-----------------|---------------------|
| **입력 데이터** | (1, D, H, W) | (1, H, W) |
| **Depth 정보** | ✅ 유지 | ❌ 손실 |
| **인접 슬라이스** | ✅ 유지 | ❌ 손실 |
| **3D Context** | ✅ 유지 | ❌ 손실 |
| **공간 연속성** | ✅ 유지 | ❌ 손실 |
| **데이터 양** | 100% | 80% (양 끝 제거) |
| **모델 복잡도** | 높음 (3D Conv) | 낮음 (2D Conv) |
| **학습 속도** | 느림 | 빠름 |
| **메모리 사용** | 많음 | 적음 |

---

## 💡 정보 손실 완화 방법 (향후 개선)

### Option 1: Multi-Slice 입력
```python
# 인접 3개 슬라이스를 채널로 사용
slice_n-1, slice_n, slice_n+1 → (3, H, W)
```
**장점:** 일부 depth 정보 복원
**단점:** 완전한 3D는 아님

### Option 2: 2.5D 방식
```python
# 여러 방향의 슬라이스 결합
axial + sagittal + coronal → multi-view
```
**장점:** 다양한 시점 정보 활용
**단점:** 복잡도 증가

### Option 3: 3D CNN으로 완전 전환
```python
# Conv2d → Conv3d 변환
# 3D 볼륨을 그대로 입력
```
**장점:** 정보 손실 없음 (이상적)
**단점:** 코드 전면 수정 필요, 계산량 증가

---

## ⚠️ 주의사항

현재 2D Slice 방식은 **빠른 프로토타입**을 위한 선택입니다.

### 장점:
✅ 기존 reconstruction 코드 재사용 가능
✅ 빠른 학습 속도
✅ 적은 메모리 사용

### 단점:
❌ 3D 정보 손실
❌ 정확도 하락 가능성
❌ Depth 방향 병변 감지 어려움

---

## 📌 결론

**현재 구현은 프로토타입용이며, 실제 성능이 중요하다면 3D 방식으로의 전환을 고려해야 합니다.**

정보 손실 지점은 코드 내에 `⚠️ [정보 손실 N]` 주석으로 표시되어 있습니다.

